[ { "title": "前端开发编码习惯", "url": "/posts/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%BC%96%E7%A0%81%E4%B9%A0%E6%83%AF/", "categories": "开发", "tags": "规范", "date": "2022-05-13 00:00:00 +0800", "snippet": "前言好的编码习惯，能够提升个人技术素养，产品质量，减少bug数量，易维护，易迭代，多人协作易沟通交接等多个好处。今天从个人角度谈谈自己的一些编码习惯，以及为什么要这么做。 这并不是什么技术标准，不同的人有不同的看法和喜好。但我们要牢记一条：优秀的代码一定是可读性非常高的代码。基础篇主要从javascript代码的基础编写的角度阐述。===与==在遇到基本数据类型判断的情况下,强制使用全等于判断===。因为js是是弱类型语言，非全等判断==会存在隐式类型转换的问题，在一个复杂的业务场景中，如果导出充斥着非全等判断，那么开发者可能会无法第一时间明确业务中过的数据类型及结构，对后来的协作开发人员也非常不友好。而在其他大部分编程语言中，包括近年火热的Typescript本身也是有解决这一问题。所以在我们开发中遇到当前场景，务必使用全等判断，如果数据类型不明确，我们也要通过其他方法转换成明确的类型再继续判断。let a = &#39;0&#39;console.log(a == false)console.log(Number(a) == false)console.log(Number(a) === false)数据类型转换数据类型转换分为强制转换和隐形转换。在大多数场景建议使用强制转换。转换字符串使用String,数字使用Number, 因为隐式转换的写法具有一定的迷惑性，大量的隐式转换放在一起会大大降低代码的可读性，某些场景下会使代码变得不稳定，增加bug排查难度，所以尽量避免书写隐式转换类型的代码。console.log(+&#39;1&#39; + &#39;1&#39; + +&#39;1&#39; )console.log(+&#39;1&#39; + +&#39;1&#39; +&#39;1&#39;)不要使用过时的Javscript技巧了解ES高版本语法，如果可以，尽可能面使用新语法开发，因为高阶语法在底层实现上性能通常会优于旧版本。一个经典的例子是搜索一个数组是否包含一个元素。 使用 array.indexOf(item) !== -1来监测元素是否存在。ECMAScript 2015及更高版本的功能变得越来越强大。 你可以使用新的语言特性安全地重构很多hacks。使用ES2015方法 array.includes(item)重构array.indexOf(item) !== -1。const arr = [1,2,3,4,5,6,7,8,9]// 查找数组arr中是否有 number 5console.log(arr.indexOf(5) !== -1) // badconsole.log(arr.includes(5)) //good// 查找数组中所有大于数字6的元素// 判断数组中所有的元素是否大于数字3// 数组中所有元素的累加和是多少不要污染函数作用域在ES6之前，通常会在顶级作用域或函数作用域顶级声明所有变量，但其实一些变量只在某一块作用域生效，所以会造成作用域污染，所以我们要尽可能的控制每一个变量的生命周期。比如ES6开始引入的块级作用域的概念，可以很方便的解决这个问题。// 错误的let message;if (notFound) { message = &#39;xxxxxx&#39; // 使用 message...}// 正确的if (notFound) { const message = &#39;xxxxxx&#39; // 使用 message...}避免使用null作为函数入参避免使函数的入参为null, 一旦null出现在调用堆栈中，就需要在每一个可能访问的函数检查中，来判断是否为null函数导出全局公共函数导出文件，不推荐export一个对象的方式，而是export一个个函数的形式。这样可以实现按需导入.// badutil.fun = function() {};export default util;// badexport default { fun}// goodexport function fun() {};import {fun} from &#39;&#39;;了解高阶函数，在正确场景使用正确的函数// 如果只是遍历const arr = [1, 2, 3];// bad arr.map(item =&amp;gt; {});// goodarr.forEach(item =&amp;gt; {});如果数据量特别大，尤其是遍历操作，推荐使用普通for循环，因为高阶函数的底层也是封装的for循环const arr = [];// beatfor (let i = 0, len = arr.length; i &amp;lt; len; i++) {}链式调用使用 缩进和.强调调用而非新语句// bad $(&#39;#items&#39;).find(&#39;.selected&#39;).highlight().end().find(&#39;.open&#39;).updateCount()// good $(&#39;#items&#39;) .find(&#39;.selected&#39;) .highlight() .end() .find(&#39;.open&#39;) .updateCount()删除无用的大篇幅代码注释删除没有必要的声明// badlet dataList = []dataList.push(row)let data = { code: this.code, list: dataList}// goodlet data = { code: this.code, list: [ row ]}事件处理注重隔离应用逻辑和用户行为，专注一个函数只做一件事，便于函数复用// badfunction handClick (event) { const popup = document.getElementById(&quot;popup&quot;) popup.style.left = event.clientX popup.style.top = event.clientY popup.className = &quot;show&quot;}// goodfunction showPopup(event){ const popup = document.getElementById(&quot;popup&quot;) popup.style.left = event.clientX popup.style.top = event.clientY popup.className = &quot;show&quot;}function handClick (event) { showPopup(event)}适当抛出自定义错误当业务变得复杂，需求变得庞大，适当的抛出自定义错误, 有助于调试，及加深业务理解。throw new Error(&#39;函数名：可能得原因&#39;)不要使用随意的编码风格（不要破坏项目的编码风格）开始一个新项目首先要确定整体代码风格，可以参考已有的代码风格，配合eslint配置验证。接手一个项目，在开始编码前，确认当前项目的代码风格并严格遵守。有什么比阅读具有随机编码风格的代码更令人生畏的呢？ 你永远不知道会发生什么！ 如果代码库包含许多开发人员的不同编码风格怎么办？ 各式各样的人物涂鸦墙。组件封装要确保组件代码可读性公共组件是团队协作的基础，可读性就显得尤为总要，怎么增加组件的可读性呢？首先组件命名要语义化，大家看到组件就一目了然，知道该组件的功能是啥；其次我们组件要有一个清晰明了的注释，演示组件用例，属性、参数、方法说明，让大家几乎不用动脑就可以完美使用/** * 表格筛选器组件 * * 使用说明： * 1，导入组件：import TableFilter from &quot;~/components/sizer/TableFilter.vue&quot; * 2，注册组件：components: {TableFilter} * 3，渲染：&amp;lt;TableFilter :listSizer=&quot;listSizer&quot; :listPrmt=&quot;listPrmt&quot; @ichub=&quot;search&quot;&amp;gt;&amp;lt;/TableFilter&amp;gt; * * 属性说明： * :listSizer：Array 过滤器基本配置项 * :listPrmt：Object 过滤参数对象 * @ichub: function 点击ichub按钮过滤事件--参数：Object 当前过滤参数对象 * * 数据说明： * listSizer: [{ /过滤器基本配置项数据 * type: &quot;text&quot;, //输入框类型：text普通输入框，select下拉输入框，date时间选择输入框 * placeholder: &quot;型号&quot;, //输入框提示 * name: &quot;sku_name&quot;, //绑定的字段名与listPrmt里面的键对应 * key: &quot;f_sku_name&quot;, //循环唯一标识key * width: &quot;g-width-15&quot; //输入框站筛选器的宽度（百分比） * }] ** /组件要注重逻辑功能和理性封装公共组件要设计好组件功能，看哪些功能需要在组件内完成，哪些功能需要暴露给父组件。我们一般的设计原则是，能在组件内完成的功能，尽量不要暴露给父组件处理。组件数据设计注重合理性哪些数据需要父组件传进组件，哪些数据是组件自身拥有，哪些数据要输出给父组件一定要条理清晰。设计原则：组件自身除了必要的数据，一般不携带大量私有数据，尽量由父组件输入，处理完后根据业务场景决定是否需要输出。组件注重扩展性我们封装公共组件基本可以满足我们百分之80到90的业务场景，但是一些个性化话的场景，需要组件的大部分功能，但是又有新的需求，这时候再开发一个新的组件没有必要，那么我们就要在原有组件的基础上加功能。这是时候我们就要用到插槽slot来做好预留，来增强组件的扩展性。代码文件适当拆分 代码篇幅过大时，解偶归类部分方法，迁移到另一个文件，再import进来使用 定义顶级常量数据, 可考虑迁移到单独的文件中管理。" }, { "title": "vue3甘特图组件", "url": "/posts/vue3%E7%94%98%E7%89%B9%E5%9B%BE/", "categories": "学习笔记", "tags": "vue3, components, gantt, 甘特图", "date": "2022-03-30 00:00:00 +0800", "snippet": "基于vue3的极简甘特图组建,支持日程重叠，覆盖，重叠提取自定义展示。基于vue3.x开发的精简版甘特图，支持重叠日程展示，支持导出gantt img和gantt Excel文件。vue3-gantt 参考链接Demo在线预览使用方式 &amp;lt;Gantt :data=&quot;data&quot; itemText=&quot;项目&quot; dateText=&quot;日期&quot; :dateRangeList=&quot;dateRangeList&quot; /&amp;gt;import { ref } from &#39;vue&#39;import Gantt from &#39;vue3-gantt&#39;const dateRangeList = ref([&#39;2022-01-01&#39;, &#39;2022-03-05&#39;])const data = ref([ { type: &#39;normal&#39;, color: &#39;&#39;, name: &#39;项目1&#39;, schedule: [ { id: 333330, name: &#39;900勇士同时在线庆祝活动&#39;, desc: &#39;这个活动很重要，6666666营收数百万，跨部门合作的一个大项目，BOSS亲自下场坐镇指挥，大家一定要团结一心!&#39;, backgroundColor: &#39;rgb(253, 211, 172)&#39;, textColor: &#39;rgb(245, 36, 9)&#39;, days: [&quot;2022-01-15&quot;,&quot;2022-02-05&quot;] }, { id: 555550, name: &#39;XXXXXX&#39;, desc: &#39;这个活动很重要，6666666营收数百万，跨部门合作的一个大项目，BOSS亲自下场坐镇指挥，大家一定要团结一心!&#39;, backgroundColor: &#39;#28f&#39;, textColor: &#39;#fff&#39;, days: [&quot;2022-02-15&quot;,&quot;2022-02-25&quot;] }, ], }, { type: &#39;normal&#39;, color: &#39;&#39;, name: &#39;流星蝴蝶剑&#39;, schedule: [ { id: 222221, name: &#39;小年活动&#39;, desc: &#39;这个活动很重要，6666666营收数百万，跨部门合作的一个大项目，BOSS亲自下场坐镇指挥，大家一定要团结一心!&#39;, backgroundColor: &#39;#482&#39;, textColor: &#39;#fff&#39;, days: [&quot;2022-02-25&quot;,&quot;2022-03-10&quot;] } ], },])组件接收参数 参数名 类型 默认值 可选值 说明 data Array[Object] [] - 甘特图数据 dateRangeList Array [] - 当前图表内的日期区间，此数组长度为2，内容为起始时间, 格式为’YYYY-MM-DD’ itemText String null - 表头描述文字 dateText String null - 表头描述文字 activeDate String 今天 - 当前时间轴高亮显示的一天，（不会覆盖日程样式），’YYYY-MM-DD’格式时间字符串 repeatMode Object 见下方 - 重叠日程展示模式配置 itemWidth Number 40 - 日期格子的宽度，最小40 itemHeight Number 40 - 日期格子的高度度，最小40 scheduleTitle Function null - 日程上面展示的文本，function接收日程信息为参数，最终使用该方法返回值渲染 borderColor String ‘#eee’ - 表格边框颜色 组件内容宽度需要自行控制把握最小宽度组件事件 参数名 类型 默认值 可选值 说明 scheduleClick Function null - 点击日程的回调事件，接收一个日程详情参数 scrollXEnd Function null - 横向滚动条滚动到底部的事件 scrollYEnd Function null - 竖向滚动条滚动到底部的事件 data配置 Array[Object] 参数名 取值 说明 type ‘alike’||’normal’ 项目类型(展示风格) color css颜色格式 当前项目背景色, type为’alike’时生效 name String 当前项目名称 schedule Array[Object] 项目日程 schedule 项目日程配置 为了便于业务开发，可以在以下基础上任意拓展字段 参数名 说明 id 日程全局唯一id name 日程名称 desc 日程描述 backgroundColor 日程背景色 textColor 日程名称展示文字颜色 days 日程日期列表Array, 数组内容为合法的连续的日期，日期格式为 YYYY-MM-DD,也可以简写为长度为2的数组，数组内容分别为起始日期 repeatMode配置 Object 参数名 可选值 默认值 说明 mode ‘cover’||’extract’ ‘cover’ 重叠日程的处理方式，正常覆盖或者单独提取重复日程再组合, cover会忽略repeatMode其余选项 backgroundColor css颜色格式 ‘#FFFFCC’ extract模式下的背景色 textColor css颜色格式 ‘#336666’ extract模式下的文字颜色 name String||Function ‘重叠日程’ 重叠日程的展示文字，Function接收一个list参数，参数为重叠日程Array desc String||Function ‘这是多个日程’ 重叠日程的描述文字，Function接收一个list参数，参数为重叠日程Array 组件实例对外暴露的方法导出当前甘特图的完整快照图片&amp;lt;Gantt ref=&quot;gantt&quot; .../&amp;gt;&amp;lt;button @click=&quot;exportImg&quot;&amp;gt;下载图片&amp;lt;/button&amp;gt;const gantt = ref(null)const exportImg = () =&amp;gt; { gantt.value.exportImg({ download: true, waterValue: &#39;YiJio制作&#39; })} exportImg 方法接收一个Object, 配置图片的导出行为, exportImg 返回一个Promise, 成功状态会接收到图片的base64值exportImg Options 参数名 可选值 默认值 说明 download Boolean true 是否自动下载图片 waterValue String ’’ 图片水印文字, 为空就不添加水印,暂不支持自定义文字样式 导出当前甘特图Excel&amp;lt;Gantt ref=&quot;gantt&quot; .../&amp;gt;&amp;lt;button @click=&quot;exportGanttExcel&quot;&amp;gt;导出Excel&amp;lt;/button&amp;gt;const gantt = ref(null)const exportGanttExcel = () =&amp;gt; { gantt.value.exportGanttExcel({ fileName: &#39;测试列表&#39; })} exportGanttExcel接收一个对象file，配置导出文件的信息exportExcel Options 参数名 可选值 默认值 说明 fileName String ‘数据’ 导出文件名称 " }, { "title": "白鹭引擎学习笔记", "url": "/posts/%E7%99%BD%E9%B9%AD%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "学习笔记", "tags": "白鹭, 游戏开发", "date": "2022-03-04 00:00:00 +0800", "snippet": "背景 初学白鹭引擎游戏开发，记录一下学习过程中的知识点色值大多数设置颜色的API接口接收参数为16进制格式的Number,其实支持16进制转为10进制格式的Number音频获取预加载的音频文件使用RES.getRes()方法，返回egret.Sound 对象，操作该对象play方法可以进行播放，play方法返回一个egret.SoundChannel对象，该对象可以设置音量，进度，停止播放删除元素如果准确知道元素父级，可以直接调用父级removeChild方法，传入要删除的对象即可如果不知道父级可以通过元素parent属性获取父级删除父级下所有元素使用removeChildren方法绑定事件键盘事件直接绑定在document上元素移动部分场景可以使用Tween缓动动画，增加流畅性碰撞检测 public hitTest(obj1:egret.DisplayObject,obj2:egret.DisplayObject):boolean { var rect1: egret.Rectangle = obj1.getBounds(); var rect2: egret.Rectangle = obj2.getBounds(); rect1.width = rect1.width * obj1.scaleX rect1.height = rect1.height * obj1.scaleY rect2.width = rect2.width * obj2.scaleX rect2.height = rect2.height * obj2.scaleY rect1.x = obj1.x; rect1.y = obj1.y; rect2.x = obj2.x; rect2.y = obj2.y; return rect1.intersects(rect2); }皮肤和控件使用UI editor 软件创建皮肤，添加控件，设置ID，设置的内容部分会以属性的形式设置在exml文件标签上，可以直接通过.的形式设置获取预加载资源default.res.json管理所有预加载资源，可以在UI editor软件中直接添加管理以及分组" }, { "title": "前端模拟帧动画实现【FaCode】", "url": "/posts/%E5%89%8D%E7%AB%AF%E6%A8%A1%E6%8B%9F%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/", "categories": "学习笔记", "tags": "canvas, js, css, img, 帧动画", "date": "2022-02-23 00:00:00 +0800", "snippet": "背景在一次需求中，产品需要在页面中展示一个动图效果。心里直接习惯性的让设计将图片做成gif格式,然后才发现，gif格式的图片在一张图中最颜色数不能超过256，所以在需求特效图片上拥有极其丰富的色彩的情况下，gif格式的图片方案显然不行了。于是决定动手亲自实现这个效果且用以后期复用，由于图片色彩较多，所以就只能将特效动画图片切成几十张连续的图片，然后通过代码实现动画切换，以达到最终效果。实现方案 css 使用animation 实现图片切换 js 使用setInterval 实现图片切换 canvas 使用canvas实现图片切换方案优劣对比 角度 CSS JS CANVAS 性能 优 低 优 拓展性 低 优 优 难易程度 低 中 高 最终方案命令行工具facode 1.x版本npm install facode -gfa mode=canvas type=jpg speed=100命令行参数 参数名 取值 默认值 说明 mode String ‘js’ 帧动画实现方式, 取值范围 ‘js’,’css’,’canvas’ speed int 200 逐帧动画间隔时长 type string ‘png’ 要合成的图片格式 path string ’./’ 输入图片路径 out string ’./’ 输出代码文件路径 loading Boolean true 是否需要展示loading, 仅支持js和canvas minify Boolean true 是否压缩生成的文件 浏览器运行环境facode 2.x版本npm install facode@2.0.0import FaCode from &#39;facode&#39;new Facode(options)options 参数名 取值 默认值 说明 id String null 帧动画盒子ID imgList Array [] 图片网络资源地址集合 mode String ‘js’ 帧动画实现方式, 取值范围 ‘js’,’css’,’canvas’ speed int 200 逐帧动画间隔时长 loading Boolean true 是否需要展示loading loadingFn Function null 自定义生成loading动画 " }, { "title": "【webpack插件】insert-webpack-plugin", "url": "/posts/webpack%E6%8F%92%E4%BB%B6%E5%AD%A6%E4%B9%A0/", "categories": "学习笔记", "tags": "webpack", "date": "2022-02-14 00:00:00 +0800", "snippet": "背景我们做的前端项目打包后的文件要上传到第三方服务器，服务器会对代码进行校验，如果代码中包含不符合第三方规范的代码，将会上传失败。比如，不允许有ES6+的代码。正常情况下我们是可以通过babel来处理这一问题的，可是我们的项目是基于vue3的,本身就包含了无法polyfill的Proxy这一核心Function。好在第三方服务器提供了跳过es6检查的方法，那就是在需要跳过es6检查的文件顶部加上一段特定的注释/* AUTHORIZATION SKIP ES6 */由于打包后的js文件较多，手动修改及其不友好，影响开发体验，所以我们可以通过webpack插件来处理打包后的js文件，给指定文件添加内容。这是一个webpack中插件比较基础的功能，但是没有看到有类似的将这一功能完善的插件，或者只是处理html的。所以这里开发了一个可以处理任意类型文件的插件主要是确定插件执行时机，在compiler emit阶段，资源生成到目录之前进行处理。安装Webpack 4npm i insert-webpack-plugin -D使用webpack.config.jsconst InsertPlugin = require(&#39;insert-webpack-plugin&#39;)module.exports = { plugins: [ new InsertPlugin({ type: /.*\\.js/, inner: [&#39;/* AUTHORIZATION SKIP ES6 */\\n&#39;] }) ]}自定义插入module.exports = { plugins: [ new InsertPlugin({ type: /.*\\.js/, insertPosition: source =&amp;gt; { return source.slice(0, 50) + &#39;\\n /* Hello World */ \\n&#39; + source.slice(51) } }) ]}选项 参数名 类型 默认值 描述 type {String|RegExp} /.*/ 要处理的文件范围 insertPosition {String|Function} ‘before’ 要插入的位置 &amp;lt;/br&amp;gt; String: ‘before’|’after’&amp;lt;/br&amp;gt;Function 接收文件source参数，值为文件内容String,使用此方式,方法必须返回处理后的String,使用Function将会忽略inner inner Array [] 要插入文件头部的内容(目前仅支持在头部插入) " }, { "title": "GIT进阶笔录", "url": "/posts/GIT%E8%BF%9B%E9%98%B6%E7%AC%94%E5%BD%95/", "categories": "学习笔记", "tags": "git", "date": "2021-12-28 00:00:00 +0800", "snippet": " 供日常工作查阅参考查看单个文件提交修改记录git log -p &amp;lt;文件名&amp;gt; # 输出 commit信息+文件改动信息git log -- -p &amp;lt;文件名&amp;gt; # 仅输出commit记录使用上一个commit信息并编辑或修改上一次commit信息git commit --amend撤销某一次commit及文件改动，并生成新的commit信息git revert &amp;lt;commit&amp;gt;# 也可以指定范围内的commit 格式为 &amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;# (x...y] 包左不包右修改最近N次提交记录(删除，合并)git rebase -i HEAD~&amp;lt;N&amp;gt;# 命令:# p, pick &amp;lt;提交&amp;gt; = 使用提交# r, reword &amp;lt;提交&amp;gt; = 使用提交，但修改提交说明# e, edit &amp;lt;提交&amp;gt; = 使用提交，进入 shell 以便进行提交修补# s, squash &amp;lt;提交&amp;gt; = 使用提交，但融合到前一个提交# f, fixup &amp;lt;提交&amp;gt; = 类似于 &quot;squash&quot;，但丢弃提交说明日志# x, exec &amp;lt;命令&amp;gt; = 使用 shell 运行命令（此行剩余部分）# b, break = 在此处停止（使用 &#39;git rebase --continue&#39; 继续变基）# d, drop &amp;lt;提交&amp;gt; = 删除提交# l, label &amp;lt;label&amp;gt; = 为当前 HEAD 打上标记# t, reset &amp;lt;label&amp;gt; = 重置 HEAD 到该标记# m, merge [-C &amp;lt;commit&amp;gt; | -c &amp;lt;commit&amp;gt;] &amp;lt;label&amp;gt; [# &amp;lt;oneline&amp;gt;]# . 创建一个合并提交，并使用原始的合并提交说明（如果没有指定# . 原始提交，使用注释部分的 oneline 作为提交说明）。使用# . -c &amp;lt;提交&amp;gt; 可以编辑提交说明。添加关联远程仓库git remote add &amp;lt;仓库名&amp;gt; &amp;lt;仓库地址&amp;gt;展示当前项目关联的所欲远程仓库名git remote -v查看远程仓库所有分支git branch -a远程仓库同步已删除的分支(清理无效的远程追踪的分支)# git remote show &amp;lt;仓库名&amp;gt; 查看remote地址，远程分支，还有本地分支与之相对应关系等信息git remote prune &amp;lt;仓库名&amp;gt;撤销commitgit reset --soft HEAD^ # 撤销commit，代码保留git reset --mixed HEAD^ # 同时撤销addgit reset --hard HEAD^ # 同时删除所有改动撤销rebasegit reflog # 查看最近操作记录git reset --hard commitID #撤销储藏git stash list # 展示当前的存储列表git stash # 贮藏当前改动git stash save &#39;xxx&#39; # 贮藏当前改动并命名git stash pop # 删除并应用最近一次贮藏 stash@{0}git stash apply # 应用最近一次贮藏 stash@{0}git stash drop # 删除最近一次贮藏 stash@{0}git stash clear # 清空贮藏git stash show # 显示最近一次储藏的 文件改动（只显示文件信息）git stash show -p # 显示最近一次贮藏的 具体改动（显示所有改动信息）cherry-pickgit cherry-pick [&amp;lt;选项&amp;gt;] &amp;lt;提交号&amp;gt;... 或：git cherry-pick &amp;lt;子命令&amp;gt; --quit 终止反转或拣选操作 --continue 继续反转或拣选操作 --abort 取消反转或拣选操作 -n, --no-commit 不要自动提交 -e, --edit 编辑提交说明 -s, --signoff 添加 Signed-off-by: 签名 -m, --mainline &amp;lt;父编号&amp;gt; 选择主干父提交编号 --rerere-autoupdate 如果可能，重用冲突解决更新索引 --strategy &amp;lt;策略&amp;gt; 合并策略 -X, --strategy-option &amp;lt;选项&amp;gt; 合并策略的选项 -S, --gpg-sign[=&amp;lt;key-id&amp;gt;] GPG 提交签名 -x 追加提交名称 --ff 允许快进式 --allow-empty 保留初始化的空提交 --allow-empty-message 允许提交说明为空 --keep-redundant-commits 保持多余的、空的提交git cherry-pick &amp;lt;commit id&amp;gt;:单独合并一个提交git cherry-pick -x &amp;lt;commit id&amp;gt;：同上，不同点：保留原提交者信息。Git从1.7.2版本开始支持批量cherry-pick，就是一次可以cherry-pick一个区间的commit。git cherry-pick &amp;lt;start-commit-id&amp;gt;..&amp;lt;end-commit-id&amp;gt;git cherry-pick &amp;lt;start-commit-id&amp;gt;^..&amp;lt;end-commit-id&amp;gt;# 前者表示把&amp;lt;start-commit-id&amp;gt;到&amp;lt;end-commit-id&amp;gt;之间(左开右闭，不包含start-commit-id)的提交cherry-pick到当前分支；后者有&quot;^&quot;标志的表示把&amp;lt;start-commit-id&amp;gt;到&amp;lt;end-commit-id&amp;gt;之间(闭区间，包含start-commit-id)的提交cherry-pick到当前分支。其中，&amp;lt;start-commit-id&amp;gt;到&amp;lt;end-commit-id&amp;gt;只需要commit-id的前6位即可，并且&amp;lt;start-commit-id&amp;gt;在时间上必须早于&amp;lt;end-commit-id&amp;gt;git 修改 commit 作者信息# 指定当前提交 作者信息git commit -m &quot;Initial commit&quot; --author=&quot;Yijio&amp;lt;123456@qq.com&amp;gt;&quot;# 修改上次commit作者信息git commit --amend --author=&quot;name&amp;lt;email&amp;gt;&quot;# 修改前N次的commit作者信息# 1. git rebase -i HEAD~n# 2. pick 修改为 edit 或者 e# 3. git commit -m &quot;Initial commit&quot; --author=&quot;name&amp;lt;email&amp;gt;&quot;# 4. git rebase continue# 修改所有提交 （未验证）git rebase -i --root项目.gitignore 文件新增文件不生效# 要清除git对所有文件的trace：git rm -r --cached .然后重新 commit清除登录信息git config --system --unset credential.helpertagtag 相关" } ]
